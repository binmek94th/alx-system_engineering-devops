Components:
2 servers running the application (App Server 1 & App Server 2)

1 load balancer (HAProxy)

1 web server (Nginx) on each application server

1 shared application codebase (replicated or via CI/CD)

1 MySQL Primary-Replica cluster (Primary + Replica)

Domain: www.foobar.com â†’ Load Balancer IP

ğŸŒ Step-by-Step Flow
A user opens a browser and types www.foobar.com

1. DNS Resolution
DNS resolves www.foobar.com to the Load Balancer's public IP (e.g., 8.8.8.8)

This is done using an A record 

2. HAProxy (Load Balancer)
Receives the request from the user

Distributes it to one of the two backend App Servers based on a load-balancing algorithm

HAProxy can also perform health checks and remove dead backends

3. App Servers
Each server has:

Nginx (web server)

Application server (e.g., PHP-FPM, Gunicorn)

Application code

They process the request and return the result back to the load balancer â†’ client

4. Database Cluster
Application servers connect to the Primary (write) or Replica (read-only) MySQL node

The replica syncs from the primary using asynchronous replication

ğŸ§± Component Justifications
Component	Why Itâ€™s Added
2 App Servers	Improve redundancy and scalabilityâ€”handle more traffic; if one fails, the other continues
HAProxy (Load Balancer)	Distributes incoming traffic, balances load, detects failures
MySQL Primary-Replica	Provides data redundancy; Replica handles read queries, Primary handles writes

âš™ï¸ Load Balancing: Algorithm & Setup
ğŸ§® Algorithm: Round-Robin
Each request is sent to the next server in sequence

Evenly distributes traffic

Simple and efficient if all servers are equal in power

backend app_servers
    balance roundrobin
    server app1 10.0.0.2:80 check
    server app2 10.0.0.3:80 check
ğŸ” Active-Active vs Active-Passive
ğŸ”¹ Active-Active (This setup)
Both servers are live and serve traffic simultaneously

Load balancer distributes requests to all healthy nodes

ğŸ”¸ Active-Passive
Only one server is active at a time

Passive server takes over if active fails (often in failover setups)

ğŸ§  Active-Active = higher throughput, better performance
Active-Passive = simpler failover but underutilizes resources

ğŸ›¢ï¸ MySQL Primary-Replica Explained
Role	Description
Primary (Master)	Accepts both read and write queries
Replica (Slave)	Accepts only read queries; syncs data from Primary via replication logs

ğŸ”„ How Replication Works:
Primary logs all changes in binary logs

Replica reads these logs and applies changes asynchronously

Delays (lag) may occur depending on traffic

Application Usage:
Writes (e.g., insert/update) â†’ Primary only

Reads (e.g., search, list) â†’ Primary or Replica, depending on routing logic

ğŸ§¯ Problems With This Infrastructure
ğŸ”´ Single Points of Failure (SPOF)
Load Balancer: If HAProxy crashes, no traffic is routed (no redundancy for it)

Database Primary: If it fails, no writes can happen (unless failover is configured)

ğŸ”’ Security Issues
No firewall: Ports are all exposed to the public

No HTTPS: All communication is in plaintext â†’ vulnerable to eavesdropping or MITM attacks

ğŸ“‰ No Monitoring
No tools like Prometheus, Grafana, or logs aggregation

Cannot detect spikes, errors, or failures proactively

No alerts when a service is down or unhealthy
